#!/usr/bin/env python3
"""
Node to find corners of ArUcCo marker
"""
import rospy
import numpy as np
from sensor_msgs.msg import Image
from geometry_msgs.msg import Point, Quaternion, Pose
from kident.msg import Point2DArray
import cv2
import utils
from scipy.spatial.transform import Rotation
import ros_numpy

class ArucoDetector():
    """
    Detect aruco markers in image
    """

    def __init__(self,aruco_marker_length=0.12,camera_matrix=np.eye(3),camera_distortion=np.zeros(5)) -> None:
        """
        Constructor
        """
        self._pub = rospy.Publisher("image_overlay", Image, queue_size=20)
        self._pub2 = rospy.Publisher("estimated_pose", Pose, queue_size=1) # create publisher
        self._sub = rospy.Subscriber("/r1/camera1/image_raw", Image, self.image_received) # create subscriber
        self.arucoDict = cv2.aruco.Dictionary_get(cv2.aruco.DICT_5X5_1000) # All 5by5 Markers
        self.arucoParams = cv2.aruco.DetectorParameters_create()

        self.aruco_length = aruco_marker_length
        self.camera_matrix = camera_matrix
        self.camera_distortion = camera_distortion
        self.corners=None

        self


    def image_received(self, image_message : Image) -> None:
        cv_image = ros_numpy.numpify(image_message)
        self.detect_markers(cv_image)
        #self.estimate_pose()

    def detect_markers(self, frame) -> None:
        (corners, ids, rejected) = cv2.aruco.detectMarkers(frame, self.arucoDict)
        # overlay_frame = cv2.aruco.drawDetectedMarkers(frame, corners,ids)
        # self._pub.publish(ros_numpy.msgify(Image, overlay_frame.astype(np.uint8), encoding='rgb8')) # convert opencv image to ROS
        rvecs, tvecs, _objPoints = cv2.aruco.estimatePoseSingleMarkers(corners, 
            self.aruco_length, 
            self.camera_matrix, 
            self.camera_distortion)
        
        #return ids, rvecs, tvecs
        return  [{"id":m[0], "rvec":m[1], "tvec":m[2], "tstamp":"TODO timestamp"} for m in zip(ids, rvecs, tvecs)]
        

    
    def estimate_pose(self):
        """
        Use the built-in pose estimation of opencv to estimate the pose of the aruco marker found by detect_markers
        """
        if np.array(self.corners==None).any(): 
            return

        rvecs, tvecs, _objPoints = cv2.aruco.estimatePoseSingleMarkers(self.corners[0], 
            self.aruco_length, 
            self.camera_matrix, 
            self.camera_distortion)
        
        
        # initiate geometry_msgs objects
        trans = Point()
        rot = Quaternion()
        pose = Pose()

        # create Point representing translation of estimated pose
        [trans.x, trans.y, trans.z] = tvecs[0][0]

        # create Quaternion representing rotation of estimated pose
        _r = Rotation.from_rotvec(rvecs[0][0]) # Rotation object from SciPy
        [rot.x, rot.y, rot.z, rot.w] = Rotation.as_quat(_r)

        # compose and publish Pose object
        pose.position=trans
        pose.orientation=rot
        # rospy.logerr('t'+str(tvecs)+'   r:'+str(rvecs))
        
        self._pub2.publish(pose)


 

# Main function.
if __name__ == "__main__":
    rospy.init_node('aruco_detector') # init ROS node named aruco_detector
    rospy.loginfo('#Node aruco_detector running#')
    arucodet = ArucoDetector()  # create instance
    
    rospy.spin()
