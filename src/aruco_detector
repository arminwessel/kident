#!/usr/bin/env python3
"""
Node to find corners of ArUcCo marker
"""
import rospy
import numpy as np
from sensor_msgs.msg import Image
from geometry_msgs.msg import Point, Quaternion, Pose
from kident.msg import Point2DArray
import cv2
import utils
from scipy.spatial.transform import Rotation
import ros_numpy

class ArucoDetector():
    """
    Detect aruco markers in image
    """

    def __init__(self,aruco_marker_length=0.12,camera_matrix=np.eye(3),camera_distortion=np.zeros(5)) -> None:
        """
        Constructor
        """
        self._pub = rospy.Publisher("image_overlay", Image, queue_size=20)
        self._pub2 = rospy.Publisher("estimated_pose", Pose, queue_size=1) # create publisher
        self._sub = rospy.Subscriber("/r1/camera1/image_raw", Image, self.image_received) # create subscriber
        self.arucoDict = cv2.aruco.Dictionary_get(cv2.aruco.DICT_5X5_1000) # All 5by5 Markers
        self.arucoParams = cv2.aruco.DetectorParameters_create()

        self.aruco_length = aruco_marker_length
        self.camera_matrix = camera_matrix
        self.camera_distortion = camera_distortion
        self.corners=None

        self


    def image_received(self, image_message : Image) -> None:
        cv_image = ros_numpy.numpify(image_message)
        self.detect_markers(cv_image)
        #self.estimate_pose()

    def detect_markers(self, frame) -> None:
        (corners, ids, rejected) = cv2.aruco.detectMarkers(frame, self.arucoDict)
        # overlay_frame = cv2.aruco.drawDetectedMarkers(frame, corners,ids)
        # self._pub.publish(ros_numpy.msgify(Image, overlay_frame.astype(np.uint8), encoding='rgb8')) # convert opencv image to ROS
        rvecs, tvecs, _objPoints = cv2.aruco.estimatePoseSingleMarkers(corners, 
            self.aruco_length, 
            self.camera_matrix, 
            self.camera_distortion)
        
        return ids, rvecs, tvecs
        

    
    def estimate_pose(self):
        """
        Use the built-in pose estimation of opencv to estimate the pose of the aruco marker found by detect_markers
        """
        if np.array(self.corners==None).any(): 
            return

        rvecs, tvecs, _objPoints = cv2.aruco.estimatePoseSingleMarkers(self.corners[0], 
            self.aruco_length, 
            self.camera_matrix, 
            self.camera_distortion)
        
        
        # initiate geometry_msgs objects
        trans = Point()
        rot = Quaternion()
        pose = Pose()

        # create Point representing translation of estimated pose
        [trans.x, trans.y, trans.z] = tvecs[0][0]

        # create Quaternion representing rotation of estimated pose
        _r = Rotation.from_rotvec(rvecs[0][0]) # Rotation object from SciPy
        [rot.x, rot.y, rot.z, rot.w] = Rotation.as_quat(_r)

        # compose and publish Pose object
        pose.position=trans
        pose.orientation=rot
        # rospy.logerr('t'+str(tvecs)+'   r:'+str(rvecs))
        
        self._pub2.publish(pose)


class PoseQueue():
    """
    Custom overflowing queue. Once max number of elements is reached the oldest element is dropped
    """
 
    # Initialize queue
    def __init__(self, max_elements):
        self.q = [None] * max_elements      # list to store queue elements
        self.capacity = max_elements        # maximum capacity of the queue
        self.front = 0                      # front points to the front element in the queue
        self.rear = -1                      # rear points to the last element in the queue
        self.count = 0                      # current size of the queue
 
    # Function to dequeue the front element
    def deq(self):
        x = self.q[self.front]
        # print('Removing element…', x)
        self.front = (self.front + 1) % self.capacity
        self.count = self.count - 1
        # check for queue underflow
        if self.isEmpty():
            # print('Queue Underflow!! Terminating process.')
            self.front=0
            self.rear=-1
        return x
 
    # Function to add an element to the queue
    def enq(self, value):
        # check for queue overflow
        if self.isFull():
            self.deq()                      # throw out element
        # print('Inserting element…', value)
        self.rear = (self.rear + 1) % self.capacity
        self.q[self.rear] = value
        self.count = self.count + 1
 
    # Function to return the front element of the queue
    def peek(self):
        if self.isEmpty():
            print("Can' peek empty queue")
            exit(-1)
        return self.q[self.front]
 
    # Function to return the size of the queue
    def size(self):
        return self.count
 
    # Function to check if the queue is empty or not
    def isEmpty(self):
        return self.size() == 0
 
    # Function to check if the queue is full or not
    def isFull(self):
        return self.size() == self.capacity

    # Function to return all elements in queue as sorted list
    def asArray(self):
        if (self.isFull()):
            return self.q[self.front:self.capacity]+self.q[0:self.front]
        else:
            return self.q[self.front:self.rear+1]
 

# Main function.
if __name__ == "__main__":
    rospy.init_node('aruco_detector') # init ROS node named aruco_detector
    rospy.loginfo('#Node aruco_detector running#')
    arucodet = ArucoDetector()  # create instance
    
    rospy.spin()
